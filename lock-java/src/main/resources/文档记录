锁笔记

1.锁的分级：
      锁分为 乐观锁，悲观锁，读写锁，自旋锁(cas无锁)，公平锁，非公平锁
      redis锁，zookeeper锁
2.重入性
   重量级锁:  synchronized   可重入，保证可见性和原子性
   轻量级锁:  lock(的ReentrantLock子类)           可重入，保证可见性和原子性
   
   可重入性又叫递归性，表示手里有把锁了(未释放状态)，还可进入自己的锁
   
3.读写锁(ReentrantReadWriteLock):
和lock的区别就是 lock只有一把锁，而ReentrantReadWriteLock有两把锁，一把控制读，一把控制写。
支持双读，但不支持双写和一读一写，只有全部写完之后在能继续读

4.乐观锁基本都是基于cas机制实现的
  乐观锁的本质是没有锁的，效率高，无阻塞，没有死锁的概念，，无需等待。
       实现：
        使用一个版本号做记录的标识符+cas操作实现
   update table set x=x+1 , version =version+1 where id=xx and version=1
   如果能更改说明数据没有被更新，如果不能更新说明数据没有被更新。如果不能更改了，可考虑从新从
   数据库中  查询这个版本号
  悲观锁的本质是无论做什么操作都会被锁住，确保在做写的操作的时候，只有一个人在执行。特点是需等待，会阻塞
  例如:
        synchronized  ReentrantReadWriteLock等
 
5.原子变量对象 atomicInteger(在java内存模型中实现了变量的原子性操作+可见性， volatile 实现了变量在内存之间的可见性)
   
   可以使用它实现对变量做++或者--等不会出现多线程下的脏读问题
 底层原理使用了 cas无锁机制
 
 (java内存模型 百度很多)
 
6.cas原理
它包含了三个参数CAS(V,E,N)
	V表示要更新的变量，(主内存中的变量值)
	E表示本地内存中的变量值   
	N表示要更新的值
 使用cas的时候会先将 v和e中的版本值进行比对，
 如果相同就可以直接更新N的值（主内存中的值没有被修改过）
 如果不同就说明主内存中的值已经被更改过，那么需要从新从主内存中将值刷新到本地内存，然后在进行修改
 机制是采用死循环的机制然后进行比对如果相同就break;之后进行修改
 它有一个缺点：ABA问题 
 在它获取主内存中值后，有新的线程修改了主内存中的值，但是过了一段时间后，又修改回来了。这样cas机制会误认为数据
 没有被修改过，数据被锁读。
 这个时候可以使用一个时间戳来确保主内存中的值和本地的值一致，不一致就从新从主内存中获取值相应的接口为atomicstampedreference
 
redis锁和zookeeper锁的区别
  获取
  redis:多个客户端(jvm)向redis中写入key，谁写入成功了，谁就获取了锁
  zookeeper:多个客户端在zookeeper中创建同一个临时节点，谁创建成功谁就获取了锁
  
 释放:
   zookeeper使用的是直接关闭临时节点的session会话连接，因为节点声明周期与session会话绑定在一起，如果session会话关闭，那么临时节点也会删除
   redis 使用的是删除key和设置key的自动过期时间来释放锁，业务执行完成后删除key，或者key的存在时间到了，自己删除
 死锁:
    redis使用了设置key的过期时间，来保证不会发生死锁问题。
    zookeeper使用会话的有效期来确保不会发生死锁问题
 性能:
    redis高,因为没有进行IO等操作
 可靠性：
    zookeeper高，因为本身机制，可以防止业务逻辑没有执行完，而发生锁过期的问题
 